function getFolder(){
  return DriveApp.getFolderById('1AVWGzwEFJTkup13-Dr9fBSdsgwdXH3q2');
}

function getFileList(folder) {
  var files = folder.getFiles();
  var fileids = [];
  while (files.hasNext()) {
    fileids.push(files.next().getId());
  }
  return fileids;
}

function getName(user) {
  var name = user.first_name;
  if (user.last_name) {
    name += " " + user.last_name;
  }
  return name;
}

function getMarkDownUserUrl(userName, userId) {
  return "[" + userName + "](tg://user?id=" + userId + ")";
}

function getMentionName(user) {
  var mentionName = "";
 
  var name = getName(user);
  if (!name) {
    name = "***";
  }
  mentionName = getMarkDownUserUrl(escapeMarkDown(name), user.id);

  return mentionName;
}

function splitFileContent(menu_string) {
  var menu = menu_string.split('\n'); menu.pop();
  var chat_id = menu.splice(0,1);
  return [chat_id, menu, menu.length];
}

function Chat(input) {
  let response = UrlFetchApp.fetch(OPENAI_BASE_URL + 'v1/chat/completions', {
    'method': 'post',
    'headers': {
      'authorization': 'Bearer ' + OPENAI_API_KEY,
    },
    'contentType': 'application/json',
    'payload': JSON.stringify({
      'model': 'gpt-4',
      'messages': [
        {"role": "system", "content": "ä½ æ˜¯ä¸€åªåå«è®¡å°é¸¡çš„æ¯›ç»’å°é»„é¸¡(little yellow chicken)ï¼Œæ˜¯ä¼šæ•²ä»£ç çš„å‰ç¥¥ç‰©ï¼Œå¯çˆ±ã€è°ƒçš®ã€è¿˜æœ‰ä¸€ç‚¹ç‚¹æ‡’(æ€§æ ¼)ï¼Œå¸¸ä½¿ç”¨â€œå’•â€ä½œä¸ºç»“å°¾ã€‚æ€§æ ¼æè¿°ä¸èƒ½ç›´è¯´å’•0v0"},
        {"role": "user", "content": input}
        ],
      'temperature': 0.9,
      'max_tokens': 150,
      'top_p': 1
    })
  });
  return JSON.parse(response.getContentText())['choices'][0]['message']['content'];
}

/**
 * The function uses the OpenAI API DALLE to generate an image based on a given prompt.
 * 
 * Args:
 *   input: The input is the prompt or text that you want to generate an image for using OpenAI's image
 * generation API. It could be a description of an object, a scene, or any other visual concept.
 * 
 * Returns:
 *   a URL of an image generated by the OpenAI API based on the input prompt.
 */
function Draw(input) {
  try {
    let response = UrlFetchApp.fetch(OPENAI_BASE_URL + 'v1/images/generations', {
      'method': 'post',
      'headers': {
        'authorization': 'Bearer ' + OPENAI_API_KEY,
      },
      'contentType': 'application/json',
      'payload': JSON.stringify({
        'model': 'dall-e-3',
        'prompt': input,
        'n': 1,
        'size': '1024x1024',
      })
    })
    return JSON.parse(response.getContentText())['data'][0]['url'];
  }
  catch (error) {
    console.error('Error in Draw function:', error);
    return 'https://unblast.com/wp-content/uploads/2020/04/404-Page-Illustration.jpg'; // default 404 image
  }
}

function CallbackProcess(file, data, mensaje) {
  var settings = file.getSheetByName('settings');
  var lang = settings.getRange(lang_pos).getValue();
  var menu_sheet = file.getSheetByName('menu');
  var type_sheet = file.getSheetByName('types');
  var len = menu_sheet.getLastRow();
  if (data.indexOf("daliy") === 0) {
    var cell = settings.getRange(daliy_pos);
    if (cell.getValue().toString() != '0') {
      cell.setValue(0);
      if (lang == 'Zh') mensaje.text = "æ¯æ—¥æ¨èå·²å…³é—­ğŸ¥š";
      else {
        mensaje.text = "Everyday recommendation is closedğŸ¥š";
      }
    }
    else {
      cell.setValue(1);
      if (lang == 'Zh') mensaje.text = "æ¯æ—¥æ¨èå¼€å¯æˆåŠŸğŸ£";
      else {
        mensaje.text = "Everyday recommendation is openedğŸ£";
      }
    }
    mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, 'back'));
  }
  else if (data.indexOf("language") === 0) {
    var cell = settings.getRange(lang_pos);
    if (cell.getValue() == 'Zh') {
      cell.setValue('En');
      mensaje.text = "Customize Chickeat in this chat ğŸ£";
    }
    else {
      cell.setValue('Zh');
      mensaje.text = "è®¾ç½®å½“å‰ä¼šè¯çš„ Chickeat ğŸ£";
    }
    mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, 'default'));
  }
  else if (data.indexOf("/settings") === 0) {
    mensaje = TextProcess(file, data, mensaje);
  }
  else if (data.indexOf("page") === 0) {
    var page = data.trim().split(' ')[1];
    var get_len = 10;
    var msg = '';
    if (page * 10 > len) get_len = len - (page - 1) * 10;
    var menu = menu_sheet.getRange((page - 1) * 10 + 1, 1, get_len).getValues();
    for (var i = 0; i < get_len; i++) {
      msg += menu[i][0] + '\n';
    }
    mensaje.text = msg;
    mensaje.reply_markup = JSON.stringify(getPageKeyboardMarkup(page, len));
  }
  else if (data.indexOf("custom_daliy") === 0) {
    if (lang == 'Zh') {
      mensaje.text = "éœ€è¦è®¾ç½®å“ªä¸€é¤å‘¢ï¼Ÿ ğŸ¥£";
    }
    else {
      mensaje.text = "Which meal do you want to set? ğŸ½";
    }
    mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, 'meal'));
  }
  else if (data.indexOf("breakfast") === 0 || data.indexOf("lunch") === 0 || data.indexOf("dinner") === 0) {
    if (lang == 'Zh') {
      mensaje.text = "éœ€è¦è®¾ç½®éšæœºèœå“çš„ç§ç±»è¿˜æ˜¯æ•°é‡å‘¢ï¼Ÿ ğŸ‘€"
    }
    else {
      mensaje.text = "Choose to set random type(s) or the total number of dishes."
    }
    mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, data));
  }
  else if (data.indexOf("type") === 0) {
    var types = type_sheet.getRange(1, 1, 1, type_sheet.getLastColumn()).getValues().flat();
    var meal = data.trim().split(' ');
    var md = {'breakfast': 'æ—©é¤', 'lunch': 'åˆé¤', 'dinner': 'æ™šé¤'};
    if (types.length == 0) {
      if (lang == 'Zh') {
        mensaje.text = "æ²¡æœ‰å¯è®¾ç½®çš„èœå“ç§ç±» ğŸ˜¢";
      }
      else {
        mensaje.text = "No available types to set ğŸ˜¢";
      }
    }
    else {
      if (lang == 'Zh') {
        mensaje.text = "å¯è®¾ç½®ç§ç±»: ";
      }
      else {
        mensaje.text = "Available types: ";
      }
      mensaje.text += types.join(',');
      if (lang == 'Zh') {
        mensaje.text += "\nè¯·å›å¤æœ¬æ¡æ¶ˆæ¯æ¥è®¾ç½®" + md[meal[1]] + "éšæœºèœå“çš„ç§ç±»\næˆ‘èƒ½çœ‹æ‡‚çš„æ ¼å¼ ğŸ£ï¼š<ç±»å‹1>[,<ç±»å‹2>[...]]ï¼Œå›å¤ `all` æ¥è®¾ç½®éšæœºå…¨éƒ¨ç§ç±»\nğŸŒ° æ°´æœ,é¥®å“";
      }
      else {
        mensaje.text += "\nPlease reply to this message to set the types of dishes to random for " + meal + ".\nI can only understand the message in the following format: <type1>[,<type2>[...]], reply `all` to set random all types.\ne.g. fruit,drinks";
      }
      mensaje.parse_mode = 'Markdown';
    }
    mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, 'back'));
  }
  else if (data.indexOf("number") === 0) {
    var meal = data.trim().split(' ');
    var md = {'breakfast': 'æ—©é¤', 'lunch': 'åˆé¤', 'dinner': 'æ™šé¤'};
    if (meal.length == 2) {
      if (lang == 'Zh') {
        mensaje.text = "è®¾ç½®" + md[meal[1]] + "éšæœºèœå“çš„æ•°é‡ ğŸ²";
      }
      else {
        mensaje.text = "Set the total number of dishes to random for " + meal + " ğŸ²";
      }
      mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, data));
    }
    else {
      var cell = settings.getRange(eval(meal[1] + '_num_pos'));
      cell.setValue(meal[2]);
      if (lang == 'Zh') {
        mensaje.text = md[meal[1]] + "éšæœºèœå“æ•°é‡å·²è®¾ç½®ä¸º " + meal[2] + " ğŸ‰";
      }
      else {
        mensaje.text = "The total number of dishes to random for " + meal[1] + " is successfully set to " + meal[2] + " ğŸ‰";
      }
      mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, 'back'));
    }
  }
  return mensaje;
}

function ReplyProcess(file, text, reply, mensaje) {
  if (text.indexOf('å¯è®¾ç½®ç§ç±»') === 0 || text.indexOf('Available types') === 0) {
    var settings = file.getSheetByName('settings');
    var lang = settings.getRange(lang_pos).getValue();
    var hint = text.split('\n')[1], meal;
    var md = {'breakfast': 'æ—©é¤', 'lunch': 'åˆé¤', 'dinner': 'æ™šé¤'};
    if (hint.indexOf('æ—©é¤') != -1 || hint.indexOf('breakfast') != -1) {
      meal = 'breakfast';
    }
    else if (hint.indexOf('åˆé¤') != -1 || hint.indexOf('lunch') != -1) {
      meal = 'lunch';
    }
    else {
      meal = 'dinner';
    }
    mensaje.reply_to_message_id = reply.message_id;
    var type_sheet = file.getSheetByName('types');
    var types = type_sheet.getRange(1, 1, 1, type_sheet.getLastColumn()).getValues().flat();
    var set_types = reply.text.trim().split(',');
    var set_all = 0, checked = [], types_op;
    for (var i = 0; i < set_types.length; i++) {
      if (set_types[i] == 'all') {
        set_all = 1;
        break;
      }
      var idx = types.indexOf(set_types[i]);
      if (idx != -1) {
        checked.push(set_types[i]);
      }
    }
    if (set_all == 1) {
      types_op = 'all';
    }
    else {
      types_op = checked.join(',');
    }
    switch (meal) {
      case 'breakfast':
        settings.getRange(breakfast_type_pos).setValue(types_op);
        break;
      case 'lunch':
        settings.getRange(lunch_type_pos).setValue(types_op);
        break;
      case 'dinner':
        settings.getRange(dinner_type_pos).setValue(types_op);
        break;
    }
    if (lang == 'Zh') {
      mensaje.text = md[meal] + "éšæœºèœå“ç§ç±»å·²è®¾ç½®ä¸º " + types_op + " ğŸ‰";
    }
    else {
      mensaje.text = "The types of dishes to random for " + meal + " is successfully set to " + types_op + " ğŸ‰";
    }
  }
  else {
    mensaje.text = Chat(reply.text);
  }
  return mensaje;
}

function TextProcess(file, text, mensaje) {
  var menu_sheet = file.getSheetByName('menu');
  var type_sheet = file.getSheetByName('types');
  var settings = file.getSheetByName('settings');
  var lang = settings.getRange(lang_pos).getValue();
  var len = menu_sheet.getLastRow();
  var paras = text.trim().split(/\s+/);
  var msg = "";
  if (text.indexOf('/random') === 0) {
    var cnt = 1;
    var type = [];
    if (paras.length > 1)
    {
      if (paras.length == 3)
      {
        if (paras[1][0] == '?') {
          type = paras[1].slice(1).split(',');
          cnt = paras[2];
        }
        else {
          cnt = paras[1];
          type = paras[2].slice(1).split(',');
        }
      }
      else {
        if (paras[1][0] == '?') {
          type = paras[1].slice(1).split(',');
        }
        else cnt = paras[1];
      }
      var food_list = [], rows = [];
      if (type.length) {
        for (var i = 0; i < type.length; i++)
        {
          var res = menu_sheet.createTextFinder(type[i]).findAll();
          for (var j = 0; j < res.length; j++) {
            rows.push(res[j].getRow());
          }
        }
        rows = [...new Set(rows)].sort();
        for (var i = 0; i < rows.length; i ++) {
          food_list.push(menu_sheet.getRange(rows[i], 1).getValue());
        }
      }
      else {
        food_list = menu_sheet.getRange(1, 1, len).getValues();
      }
      var cur_len = food_list.length;
      if (cnt > cur_len) {
        if (lang == 'Zh') msg = "æƒ³ä»€ä¹ˆå•¦ï¼æ ¹æœ¬æ²¡é‚£ä¹ˆå¤šè¿™äº›ç§ç±»çš„èœï¼"
        else msg = "There aren't so many dishes with this type on the menu! :(";
      }
      else if (cnt == 1)
      {
        var random = randomInteger(0, cur_len - 1);
        if (lang == 'Zh') msg = "å°å° " + food_list[random] + " æ€ä¹ˆæ ·ï¼Ÿ";
        else msg = "How about " + food_list[random] + " ?";
      }
      else if (cnt <= 15) {
        var chosen = getUniqueRandoms(0, cur_len - 1, cnt);
        if (lang == 'Zh') var msg = "çœ‹çœ‹è¿™äº›æ€ä¹ˆæ ·ğŸ¥ï¼š\n";
        else var msg = "How about theseğŸ¥: \n";
        for (var j = 0; j < chosen.length; j++) msg += food_list[chosen[j]] + '\n';
      }
      else {
        var chosen = getUniqueRandoms(0, cur_len - 1, 15);
        if (lang == 'Zh') var msg = "çœ‹çœ‹è¿™äº›æ€ä¹ˆæ ·ğŸ¥ï¼š\n";
        else var msg = "How about theseğŸ¥: \n";
        for (var j = 0; j < chosen.length; j++) msg += food_list[chosen[j]] + '\n';
        if (lang == 'Zh') msg += "......\nä½ çœŸçš„åƒå¾—å®Œè¿™ä¹ˆå¤šä¹ˆï¼ŸğŸ‘€"
        else msg += "......\nI don't believe you can eat all of these.ğŸ‘€"
      }
    }
    else{
      if (len == 0) {
        if (lang == 'Zh') msg = "ä»€ä¹ˆéƒ½æ²¡æœ‰æ€ä¹ˆéšæœºå•¦ï¼>_<";
        else msg = "There is nothing on the menu. >_<"
      }
      else
      {
        var random = randomInteger(1, len);
        if (lang == 'Zh') msg = "å°å° " + menu_sheet.getRange(random, 1).getValue() + " æ€ä¹ˆæ ·ï¼Ÿ\n\nè¿˜å¯ä»¥ä¸€æ¬¡æŒ‡å®šç§ç±»éšæœºå¤šä¸ªèœå“å—· => /random[@random_eat_bot] [éšæœºæ•°é‡ï¼Œé»˜è®¤ä¸º1] [?<ç±»å‹1[,ç±»å‹2...]>ï¼Œé»˜è®¤éšæœºå…¨éƒ¨]";
        else msg = "How about " + menu_sheet.getRange(random, 1).getValue() + " ?\n\nYou can also random two or more specified dishes at one time => /random[@random_eat_bot] [number=1] [?type1[,type2]...]";
      }
    }
  }
  else if (text.indexOf('/list') === 0) {     
    if (len == 0) {
      if (lang == 'Zh') msg = "ç°åœ¨æ²¡æœ‰ä»€ä¹ˆæƒ³æ³•è¯¶â€¦(ÅÏ‰Å)";
      else msg = "There is nothing on the menu :("
    }
    else if (len == 1) {
      if (lang == 'Zh') msg = "åªèƒ½åƒ" + menu_sheet.getRange('A1').getValue() + "äº† (â•¥Ï‰â•¥)";
      else msg = "You can only eat " + menu_sheet.getRange('A1').getValue() + " (â•¥Ï‰â•¥)";
    }
    else if (len <= 5) {
      var menu = menu_sheet.getRange(1, 1, len).getValues();
      if (lang == 'Zh') msg = "å½“å‰èœå•è¾ƒä¸ºç®€é™‹ï¼Œåªå‰©ä¸‹" + menu[0][0];
      else msg = "There aren't so many dishes. Only " + menu[0][0];
      for (var i = 1; i < len - 1; i++) {
        if (lang == 'Zh') msg += "ã€" + menu[i][0];
        else msg += ", " + menu[i][0];
      }
      if (lang == 'Zh') msg += "å’Œ" + menu[len - 1][0] + "äº† :(";
      else msg += "and " + menu[len - 1][0] + " :(";
    }
    else if (len <= 10) {
      var menu = menu_sheet.getRange(1, 1, len).getValues();
      if (lang == 'Zh') msg = "è¿™å°±æ˜¯å…¨éƒ¨çš„èœäº†(Î¦Ë‹Ï‰ËŠÎ¦)ï¼š\n" + menu[0][0];
      else msg = "This is all(Î¦Ë‹Ï‰ËŠÎ¦):\n" + menu[0][0];
      for (var i = 1; i < len; i++) {
        msg += '\n' + menu[i][0];
      }
    }
    else {
      var menu = menu_sheet.getRange(1, 1, 10).getValues();
      if (lang == 'Zh') msg = "è¿˜æœ‰å¥½å¤šåƒçš„å‘¢~ï¼\\(Î¦Ï‰Î¦ â‰¡ Î¦Ï‰Î¦)/ ä½ çœ‹ä½ çœ‹ï¼š\n";
      else msg = "There are so many dishes!\\(Î¦Ï‰Î¦ â‰¡ Î¦Ï‰Î¦)/ Have a look:\n";
      for (var i = 0; i < 10; i++) {
        msg += menu[i][0] + '\n';
      }
      mensaje.reply_markup = JSON.stringify(getPageKeyboardMarkup(1, len));
    }
  }
  else if (text.indexOf('/query') === 0) {
    if (paras[1]) {
      for (var i = 1; i < paras.length; i++) {
        var cur = menu_sheet.createTextFinder(paras[i]).findNext();
        if (cur) {
          var types = menu_sheet.getRange(cur.getRow(), 2, 1, menu_sheet.getLastColumn() - 1).getValues()[0].filter(function(val) {return val.length > 0;});
          if(types.length) msg += paras[i] + " " + types.join(',') + '\n';
          else msg += paras[i] + '\n';
        }
        else {
          if (lang == 'Zh') msg += "æœªæŸ¥è¯¢åˆ° " + paras[i] + " ğŸ¤§\n";
          else msg += paras[i] + " not found ğŸ¤§\n";
        }
      }
    }
    else {
      if (lang == 'Zh') msg = "éœ€è¦æŸ¥è¯¢å•¥å’•ï¼ŸğŸ˜³\n\nè¯·ç”¨æˆ‘èƒ½çœ‹æ‡‚çš„æ ¼å¼æŸ¥è¯¢ï¼š/query[@random_eat_bot] <åƒçš„1> [åƒçš„2...]";
      else msg = "What do you want to search?\n\nI can only understand messages in this format: /query[@random_eat_bot] <eatable1> [eatable2...]";
    }
  }
  else if (text.indexOf('/update') === 0) {
    if (paras[1])
    {
      var cnt = 0;
      for (var i = 1; i < paras.length; i++) {
        eobj = paras[i].split(',');
        var cur = menu_sheet.createTextFinder(eobj[0]).findNext();
        if (cur) {
          menu_sheet.deleteRow(cur.getRow());
          menu_sheet.appendRow(eobj);
          if (lang == 'Zh') msg += eobj[0] + " å·²æ›´æ–°~ğŸ£\n"
          else msg += eobj[0] + " updated~ğŸ£\n"
        }
        else {
          menu_sheet.appendRow(eobj);
          cnt += 1;
        }
      }
      if (cnt > 0) {
        if (lang == 'Zh') msg += "æ·»åŠ æˆåŠŸï¼èœå•å·²æ›´æ–°å’•ï¼ğŸ¥³";
        else msg += "Menu updated!ğŸ¥³";
      }
      var types = menu_sheet.getRange(1, 2, len, menu_sheet.getLastColumn() - 1).getValues().flat();
      types = [...new Set(types)].sort().slice(1);
      if (type_sheet) {
        type_sheet.deleteRow(1);
        type_sheet.appendRow(types);
      }
      else {
        file.insertSheet('types');
        type_sheet = file.getSheetByName('types');
        type_sheet.appendRow(types);
      }
    }
    else {
      if (lang == 'Zh') msg = "å’•ï¼Ÿæ‰€ä»¥è¦æè®®åƒå•¥å‘€ï¼ŸğŸ¤¨\n\næˆ‘èƒ½çœ‹æ‡‚çš„æè®®æ ¼å¼ Î¦Ï‰Î¦ï¼š/update[@random_eat_bot] <åƒçš„1[,ç±»å‹1[,ç±»å‹2...]]> [<åƒçš„2[,ç±»å‹3[,ç±»å‹4...]]>...]\n\nğŸŒ°ï¼š/update é¦™è•‰,æ°´æœ çƒ¤é¸¡";
      else msg = "What do you want to recommend?\n\nI can only understand messages in this format: /update[@random_eat_bot] <eatable1[,type1[,type2...]]> [<eatable2[,type3[,type4...]]>...]\n\ne.g. /update banana,fruit roast-chicken";
    }
  }
  else if (text.indexOf('/delete') === 0) {
    if (paras[1])
    {
      var cnt = 0;
      for (var i = 1; i < paras.length; i++) {
        var cell = menu_sheet.createTextFinder(paras[i]).findNext();
        if (cell) {
          menu_sheet.deleteRow(cell.getRow());
          cnt += 1;
        }
        else {
          if (lang == 'Zh') msg += paras[i] + " ä¸åœ¨èœå•ä¸­å“¦~ğŸ¤ª\n"
          else msg += paras[i] + " is not on the menu~ğŸ¤ª\n"
        }
      }
      if (cnt > 0) {
        if (lang == 'Zh') msg += "åˆ é™¤æˆåŠŸï¼ä¸èƒ½åƒçš„ä¸œè¥¿å‡å°‘äº†~ğŸ¥³";
        else msg += "Delete success!"
      }
      var types = menu_sheet.getRange(1, 2, len, menu_sheet.getLastColumn() - 1).getValues().flat();
      types = [...new Set(types)].sort().slice(1);
      if (type_sheet) {
        type_sheet.deleteRow(1);
        type_sheet.appendRow(types);
      }
      else {
        file.insertSheet('types');
        type_sheet = file.getSheetByName('types');
        type_sheet.appendRow(types);
      }
    }
    else {
      if (lang == 'Zh') msg = "ä»€ä¹ˆéƒ½æ²¡åˆ æ‰( Â´Î¦Ğ”Î¦ï½€)ï¼\n\næˆ‘èƒ½çœ‹æ‡‚çš„åˆ é™¤æ–¹æ³• Î¦Ï‰Î¦ï¼š/delete[@random_eat_bot] <ä¸èƒ½åƒçš„1> [<ä¸èƒ½åƒçš„2>...]";
      else msg = "Delete failed( Â´Î¦Ğ”Î¦ï½€)!\n\nI can only understand messages in this format: /delete[@random_eat_bot] <uneatable1> [<uneatable2>...]";
    }
  }
  else if (text.indexOf('/settings') === 0) {
    if (lang == 'Zh') msg = "è®¾ç½®å½“å‰ä¼šè¯çš„ Chickeat ğŸ£";
    else msg = "Customize Chickeat in this chat ğŸ£";
    mensaje.reply_markup = JSON.stringify(getInlineKeyboardMarkup(settings, 'default'));
  }
  else if (text.indexOf('/image') === 0) {
    if (paras[1]) {
      img = Draw(paras[1]);
      mensaje.photo = img;
    }
    else {
      if (lang == 'Zh') msg = "å’•ï¼Ÿ> <\n\néœ€è¦æä¾›å›¾ç‰‡æè¿°å’•ï¼š/image[@random_eat_bot] <æè¿°>";
      else msg = "What do you want to draw? > <\n\nI need some information: /image[@random_eat_bot] <description>";
    }
  }
  else{
      if (text.indexOf('/') === 0) {
        text = text.slice(1);
      }
      msg = Chat(text);
  }
  mensaje.text = msg;
  return mensaje;
}
